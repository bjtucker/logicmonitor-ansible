#!/usr/bin/python



import urllib
import urlparse
import json
import sys
import os
import platform
import subprocess
import hashlib
import socket
import shlex
import datetime
from datetime import datetime, time, tzinfo, timedelta
from subprocess import call
from subprocess import Popen

class LogicMonitor(object):

    def __init__(self, module, **kwargs):
        self.module                 = module
        self.company                = kwargs["company"]
        self.user                   = kwargs["user"]
        self.password               = kwargs["password"]
        if 'digest' in kwargs:
            self.digest             = kwargs['digest']
        else:
            self.digest             = False
        #end 
        if self.digest:
            self.password_digest    = self.password
        else:
            m = hashlib.md5()
            m.update(self.password)
            self.password_digest    = m.hexdigest()
        #end if lm_credentials
        self.fqdn           = socket.getfqdn()
        
        
    #end __init__

    def rpc(self, action, params):
        """Make a call to the LogicMonitor RPC library and return the response"""
        param_str = urllib.urlencode(params)
        creds = urllib.urlencode({"c": self.company, "u": self.user, "pmd5": self.password_digest})
        if param_str:
            param_str = param_str + "&"
        param_str = param_str + creds
        try:
            f = urllib.urlopen("https://{0}.logicmonitor.com/santaba/rpc/{1}?{2}".format(self.company, action, param_str))
            return f.read()
        except IOError as ioe:
            print ioe
            sys.exit(1)
        #end try
    #end rpc

    def do(self, action, params):
        """Make a call to the LogicMonitor server \"do\" function"""
        param_str = urllib.urlencode(params)
        creds = urllib.urlencode({"c": self.company, "u": self.user, "pmd5": self.password_digest})
        if param_str:
            param_str = param_str + "&"
        param_str = param_str + creds
        try:
            f = urllib.urlopen("https://{0}.logicmonitor.com/santaba/do/{1}?{2}".format(self.company, action, param_str))
            return f.read()
        except IOError as ioe:
            print ioe
            sys.exit(1)
        #end try
    #end do
    
    def getcollectors(self):
        """Returns a JSON object containing a list of LogicMonitor collectors"""
        resp = self.rpc("getAgents", {})
        resp_json = json.loads(resp)
        if resp_json["status"] is 200:
             return resp_json["data"]
        else:
            self.module.fail_json(msg=resp)
        #end if
    #end getcollectors

    def gethostbyhostname(self, hostname, collector):
        hostlist_json = json.loads(self.rpc("getHosts", {"hostGroupId": 1}))
        if collector is not None and hostlist_json["status"] == 200:
            hosts = hostlist_json["data"]["hosts"]
            for host in hosts:
                if host["hostName"] == hostname and host["agentId"] == collector["id"]:
                    return host
                #end if
            #end for
            return None
        else:
           return None
        #end if
    #end gethostbyhostname

    def gethostbydisplayname(self, displayname):
        host_json = json.loads(self.rpc("getHost", {"displayName": displayname}))
        if host_json["status"] == 200:
            return host_json["data"]
        else:
           return None
        #end if
    #end gethostbydisplayname
    
    def getcollectorbydescription(self, description):
        """return the collector json object for the collector with the matching FQDN (description) in your LogicMonitor account"""
        collector_list = self.getcollectors()
        if collector_list is not None:
            for collector in collector_list:
                if collector["description"] == description:
                    return collector
                #end if
            #end for
        #end if
        return None
    #end getcollectorbydescription
    
    def getgroup(self, fullpath):
        """Return a JSON object with the current state of a group in your LogicMonitor account"""
        resp = json.loads(self.rpc("getHostGroups", {}))
        if resp["status"] == 200:
            groups = resp["data"]
            for group in groups:
                if group["fullPath"] == fullpath.lstrip('/'):
                    return group
                #end if
            #end for
        else:
           self.module.fail_json(msg="Error: Unable to retreive the list of host groups from the server.")
        #end if
        return None
    #end getgroup
    
    def creategroup(self, fullpath):
        """Recursively create a path of host groups. return value is the id of the newly created hostgroup in your LogicMonitor account"""
        if self.getgroup(fullpath):
            return self.getgroup(fullpath)["id"]
        #end if
        parentpath, name = fullpath.rsplit('/', 1)
        parentgroup = self.getgroup(parentpath)
        if fullpath == "/":
            return 1
        elif parentpath == "":
            parentid = 1
            self.change = True
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            resp = json.loads(self.rpc("addHostGroup", {"name": name, "parentId": parentid, "alertEnable": True}))
            if resp["status"] == 200:
                return resp["data"]["id"]
            else:
               self.module.fail_json(msg="Error: unable to create new hostgroup.\n%s" % resp["errmsg"])
            #end if
        elif parentgroup:
            parentid = parentgroup["id"]
            self.change = True
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            resp = json.loads(self.rpc("addHostGroup", {"name": name, "parentId": parentid, "alertEnable": True}))
            if resp["status"] == 200:
                return resp["data"]["id"]
            else:
               self.module.fail_json(msg="Error: unable to create new hostgroup.\n%s" % resp["errmsg"])
            #end if
        else:
            self.change = True
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            resp = json.loads(self.rpc("addHostGroup", {"name": name, "parentId": self.creategroup(parentpath), "alertEnable": True}))
            if resp["status"] == 200:
                return resp["data"]["id"]
            else:
               self.module.fail_json(msg="Error: unable to create new hostgroup.\n%s" % resp["errmsg"])
            #end if
            
        #end if
    #end _createparentgroup
    
#end Logicmonitor

class Collector(LogicMonitor):
    
    
    def __init__(self, module):
        """Initializor for the LogicMonitor Collector object"""
        LogicMonitor.__init__(self, module, **module.params)
        if self.module.params['description']:
            self.description    = self.module.params['description']
        else:
            self.description = self.fqdn
        #end if
        self.info           = self._get()
        self.installdir     = "/usr/local/logicmonitor"
        self.change     = False
        if self.info is None:
            self.id         = None
        else:
            self.id         = self.info["id"]
        #end if
        self.platform       = platform.system()
        self.is_64bits      = sys.maxsize > 2**32
        self.duration       = self.module.params['duration']
        self.starttime       = self.module.params['starttime']
    #end __init__
        
    ####################################
    #                                  #
    #    Public methods                #
    #                                  #
    ####################################
    
    def create(self):
        """idempotent function to make sure that there is a running collector installed and registered in your LogicMonitor Account"""
        self._create()
        self.getinstallerbin()
        self.install()
        self.start()
    #end create

    def destroy(self):
        """idempotent function to make sure that there is a running collector installed and registered in your LogicMonitor Account"""
        self.stop()
        self.uninstall()
        self._delete()
    #end create
    
    def getinstallerbin(self):
        """Download the LogicMonitor collector installer binary"""
        arch = 32
        if self.is_64bits:
            arch = 64
        #end
        if self.platform == "Linux" and self.id is not None:
            installfilepath = self.installdir + "/logicmonitorsetup" + str(self.id) + "_" + str(arch) + ".bin"
            if not os.path.isfile(installfilepath):             #create the installer file and return the file object
                self.change = True #set change flag to show that something was update
                if self.module.check_mode:
                    self.module.exit_json(changed=True)
                #end if
                with open(installfilepath, "w") as f:
                    installer = self.do("logicmonitorsetup", {"id": self.id, "arch": arch})
                    f.write(installer)
                f.closed
                #end with
            #end if not
            return installfilepath
        elif self.id is None:
            self.module.fail_json(msg="Error: There is currently no collector associated with this device. To download the installer, first create a collector for this device.")
        elif self.platform != "Linux":
            self.module.fail_json(msg="Error: LogicMonitor Collector must be installed on a Linux device.")
        else:
            self.module.fail_json(msg="Error: Something went wrong. We were unable to retrieve the installer from the server")
        #end if
    #end getinstallerbin
    
    def install(self):
        """Execute the LogicMonitor installer if not already installed"""
        if self.platform == "Linux":
            installer = self.getinstallerbin()
            if not os.path.exists(self.installdir + "/agent") or (self._get()["platform"] != 'linux'):
                self.change = True #set change flag to show that something was update
                if self.module.check_mode:
                    self.module.exit_json(changed=True)
                #end if
                os.chmod(installer, 755)
                output = call([installer, "-y"])
                if output != 0:
                    self.module.fail_json(msg="There was an issue installing the collector")
                #end if
            #end if not
        else:
            self.module.fail_json(msg="Error: LogicMonitor Collector must be installed on a Linux device.")
        #end if
    #end install

    def uninstall(self):
        """Uninstall LogicMontitor collector from the system"""
        uninstallfile = self.installdir + "/agent/bin/uninstall.pl"
        if os.path.isfile(uninstallfile):
            self.change = True #set change flag to show that something was update
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            output = call([uninstallfile])
            if output != 0:
                self.module.fail_json(msg="There was an issue installing the collector")
            #end if
        else:
            self.module.fail_json(msg="Unable to uninstall LogicMonitor Collector. Can not find LogicMonitor uninstaller.")
        #end if
    #end uninstall
    
    def start(self):
        """Start the LogicMonitor collector"""
        if self.platform == "Linux":
            a = Popen(["service", "logicmonitor-agent", "status"], stdout=subprocess.PIPE)
            (aoutput, aerror) = a.communicate()
            if "is running" not in aoutput:
                self.change = True #set change flag to show that something was update
                if self.module.check_mode:
                    self.module.exit_json(changed=True)
                #end if
                call(["service", "logicmonitor-agent", "start"])
            #end if
            w = Popen(["service", "logicmonitor-watchdog", "status"], stdout=subprocess.PIPE)
            (woutput, werror) = w.communicate()
            if "is running" not in woutput:
                self.change = True #set change flag to show that something was update
                if self.module.check_mode:
                    self.module.exit_json(changed=True)
                #end if
                call(["service", "logicmonitor-watchdog", "start"])
            #end if
        else:
            self.module.fail_json(msg="Error: LogicMonitor Collector must be installed on a Linux device.")
        #end if
    #end start
    
    def restart(self):
        """Restart the LogicMonitor collector"""
        """Start the LogicMonitor collector"""
        if self.platform == "Linux":
            call(["service", "logicmonitor-agent", "restart"])
            call(["service", "logicmonitor-watchdog", "restart"])
        else:
            self.module.fail_json(msg="Error: LogicMonitor Collector must be installed on a Linux device.")
        #end if
    #end restart
    
    def stop(self):
        """Stop the LogicMonitor collector"""
        if self.platform == "Linux":
            a = Popen(["service", "logicmonitor-agent", "status"], stdout=subprocess.PIPE)
            (aoutput, aerror) = a.communicate()
            if "is running" in aoutput:
                call(["service", "logicmonitor-agent", "stop"])
            #end if
            w = Popen(["service", "logicmonitor-watchdog", "status"], stdout=subprocess.PIPE)
            (woutput, werror) = w.communicate()
            if "is running" in woutput:
                call(["service", "logicmonitor-watchdog", "stop"])
            #end if
        else:
            self.module.fail_json(msg="Error: LogicMonitor Collector must be installed on a Linux device.")
        #end if
    #end stop
    
    def sdt(self):
        duration = self.duration
        starttime = self.starttime
        """create a scheduled down time (maintenance window) for this host"""
        accountresp = json.loads(self.rpc("getCompanySettings", {}))
        if accountresp["status"] == 200:
            offset = accountresp["data"]["offset"]
            if starttime:
                start = datetime.strptime(starttime, '%Y-%m-%d %H:%M')
            else:
                start = datetime.utcnow()
            #end if
            offsetstart = start + timedelta(0, offset)
            offsetend = offsetstart + timedelta(0, duration*60)
            resp = json.loads(self.rpc("setAgentSDT", {"agentId": self.id, "type": 1, "notifyCC": True,
            "year": offsetstart.year, "month": offsetstart.month, "day": offsetstart.day, "hour": offsetstart.hour, "minute": offsetstart.minute,
            "endYear": offsetend.year, "endMonth": offsetend.month, "endDay": offsetend.day, "endHour": offsetend.hour, "endMinute": offsetend.minute,
            }))
            if resp["status"] == 200:
                return resp["data"]
            else:
                return None
            #end
        else:
            self.module.fail_json(msg="Error: Unable to retrieve timezone offset")
        #end if
    #end sdt

    ####################################
    #                                  #
    #    internal methods              #
    #                                  #
    ####################################    

    def _get(self):
        """Returns a JSON object representing the collector"""
        collector_list = self.getcollectors()
        if collector_list is not None:
            for collector in collector_list:
                if collector["description"] == self.description:
                    return collector
                #end if
            #end for
        #end if
        return None
    #end _get
        
    def _create(self):
        """Create a new collector in the LogicMonitor account associated with this device"""
        ret = self._get()
        if ret is None:
            self.change = True #set change flag to show that something was update
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            create_json = json.loads(self.rpc("addAgent", {"autogen": True, "description": self.description}))
            if create_json["status"] is 200:
                self.info = create_json["data"]
                self.id = create_json["data"]["id"]
                return create_json["data"]
            else:
                self.module.fail_json(msg=json.dumps(msg=create_json))
            #end if
        else:
            self.info = ret
            self.id = ret["id"]
            return ret
        #end if
    #end create

    def _delete(self):
        """Delete this collector from the associated LogicMonitor account"""
        if self._get is not None:
            delete_json = json.loads(self.rpc("deleteAgent", {"id": self.id}))
            if delete_json["status"] is 200:
                return delete_json["data"]
            else:
                self.module.fail_json(msg=json.dumps(msg=delete_json))
            #end if
        else:
            return None
        # end if
    #end delete

#end Collector

class Host(LogicMonitor):
    
    def __init__(self, module):
        """Initializor for the LogicMonitor host object"""
        LogicMonitor.__init__(self, module, **module.params)
        if self.module.params["collector"]:
            self.collector   = self.getcollectorbydescription(self.module.params["collector"])
        else:
            self.collector   = None
        #end if
        if self.module.params["hostname"]:
            self.hostname    = self.module.params['hostname']
        else:
            self.hostname    = self.fqdn
        #end if
        if self.module.params["displayname"]:
            self.displayname = self.module.params['displayname']
        else:
            self.displayname = self.fqdn
        #end if
        self.info = self.gethostbydisplayname(self.displayname) or self.gethostbyhostname(self.hostname, self.collector)
#        if self.module.params["properties"].instanceof(str):
        self.properties  = self.module.params["properties"]
        self.groups      = self.module.params["groups"]
        self.description = self.module.params["description"]
        self.alertenable = self.module.params["alertenable"]
        self.starttime    = self.module.params["starttime"]
        self.duration    = self.module.params["duration"]
        self.change = False
    #end __init__
    
    ####################################
    #                                  #
    #    Public methods                #
    #                                  #
    ####################################    
    
    
    def create(self):
        """Idemopotent function to create if missing, update if changed, or skip"""
        self.update()
    #end create
        
    
    def getproperties(self):
        """Returns a hash of the properties associated with this LogicMonitor host"""
        if self.info:
            properties_json = json.loads(self.rpc("getHostProperties", {'hostId': self.info["id"], "filterSystemProperties": True, "finalResult": False}))
            if properties_json["status"] == 200:
                return properties_json["data"]
            else:
                print "Error: there was an issue retrieving the host properties"
                print json.dumps(properties_json)
                exit(properties_json["status"])
            #end if
        else:
            print "Unable to find LogicMonitor host which matches {0} ({1})".format(self.displayname, self.hostname) 
            return None
        #end
    #end getproperties

    def setproperties(self, propertyhash):
        """update the host to have the properties contained in the property hash"""
        self.properties = propertyhash
    #end setproperties

    def add(self):
        """Add this device to monitoring in your LogicMonitor account"""
        if self.collector and not self.info:
            self.change = True
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            return self.rpc("addHost", self._buildhosthash( self.hostname, self.displayname, self.collector, self.description, self.groups, self.properties, self.alertenable))
        #end if
    #end add_host

    def update(self):
        """This method takes changes made to this host and applies them to the corresponding host in your LogicMonitor account."""
        if self.info:
            if self.ischanged():
                self.change = True
                if self.module.check_mode:
                    self.module.exit_json(changed=True)
                #end if
                h =  self._buildhosthash( self.hostname, self.displayname, self.collector, self.description, self.groups, self.properties, self.alertenable)
                h["id"] = self.info["id"]
                resp = json.loads(self.rpc("updateHost", h))
                self.module.exit_json(changed=True, msg=json.dumps(resp))
                if resp["status"] == 200:
                    return resp["data"]
                else:
                    self.module.fail_json(msg="Error: unable to update the host.")
                    exit(resp["status"])
            else:
                return self.info
            #end if
        else:
            self.change = True
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            return self.rpc("addHost", self._buildhosthash( self.hostname, self.displayname, self.collector, self.description, self.groups, self.properties, self.alertenable))
        #end if
    #end update_host
        
    def remove(self):
        """remove this host from your LogicMonitor account"""
        if self.info:
            self.change = True
            if self.module.check_mode:
                self.module.exit_json(changed=True)
            #end if
            return json.loads(self.rpc("deleteHost", {"id": self.info["id"], "deleteFromSystem": True, "hostGroupId": 1}))
        #end if
    #end remove
    
    def ischanged(self):
        """Return true if the host doesn't match the LogicMonitor account"""
        ignore = ['system.categories', 'snmp.version']
        hostresp = self.gethostbydisplayname(self.displayname) or self.gethostbyhostname(self.hostname)
        propresp = self.getproperties()
        if propresp and hostresp:
            if hostresp["alertEnable"] != self.alertenable:
                return True
            #end if
            if hostresp["description"] != self.description:
                return True
            #end if
            if hostresp["displayedAs"] != self.displayname:
                return True
            #end if
            if hostresp["agentId"] != self.collector["id"]:
                return True
            #end if
            g = []
            fullpathinids = hostresp["fullPathInIds"]
            for path in fullpathinids:
                hgresp = json.loads(self.rpc("getHostGroup", {'hostGroupId': path[-1]}))
                if hgresp["status"] == 200 and hgresp["data"]["appliesTo"] == "":
                    g.append(path[-1])
                #end if
            #end for
            for group in self.groups:
                groupjson = self.getgroup(group)
                if groupjson is None:
                    return True
                elif groupjson['id'] not in g:
                    return True
                else:
                    g.remove(groupjson['id'])
                #end if
            #end for
            if g != []:
                return True
            #end
            p = {}
            for prop in propresp:
                if prop["name"] not in ignore:
                    if "*******" in prop["value"] and self._verifyproperty(prop["name"]):
                        p[prop["name"]] = self.properties[prop["name"]]
                    else:
                        p[prop["name"]] = prop["value"]
                    #end if
                #end if
            #end for
            
            if p != self.properties:
                return True
            #end if
        else:
            exit(1)
        #end if
        return False
    #end ischanged
    
    def sdt(self):
        """create a scheduled down time (maintenance window) for this host"""
        duration = self.duration
        starttime = self.starttime
        self.change = True
        if self.module.check_mode:
            self.module.exit_json(changed=True)
        #end if
        accountresp = json.loads(self.rpc("getCompanySettings", {}))
        if accountresp["status"] == 200:
            offset = accountresp["data"]["offset"]
            if starttime:
                start = datetime.strptime(starttime, '%Y-%m-%d %H:%M')
            else:
                start = datetime.utcnow()
            #end if
            offsetstart = start + timedelta(0, offset)
            offsetend = offsetstart + timedelta(0, duration*60)
            resp = json.loads(self.rpc("setHostSDT", {"hostId": self.info["id"], "type": 1, "notifyCC": True,
            "year": offsetstart.year, "month": offsetstart.month - 1, "day": offsetstart.day, "hour": offsetstart.hour, "minute": offsetstart.minute,
            "endYear": offsetend.year, "endMonth": offsetend.month- 1, "endDay": offsetend.day, "endHour": offsetend.hour, "endMinute": offsetend.minute,
            }))
            if resp["status"] == 200:
                return resp["data"]
            else:
                return None
            #end
        else:
            self.module.fail_json("Error: Unable to retrieve timezone offset")
        #end if
    #end sdt


    ####################################
    #                                  #
    #    internal utility methods      #
    #                                  #
    ####################################
    
    def _buildhosthash(self, hostname, displayname, collector, description, groups, properties, alertenable):
        """Return a property formated hash for the creation of a host using the rpc function"""
        h = {}
        h["hostName"] = hostname
        h["displayedAs"] = displayname
        if collector:
            h["agentId"] = collector["id"]
        else:
           self.module.fail_json(msg="Error: Unable to build host hash. No collector found.")
        #end if
        if description:
            h["description"] = description
        #end if
        if groups != []:
            groupids = ""
            for group in groups:
                groupids = groupids + str(self.creategroup(group)) + ","
            #end for
            h["hostGroupIds"] = groupids.rstrip(',')
        #end if
        if properties != {}:
            propnum = 0        
            for key, value in properties.iteritems():
                h["propName{0}".format(str(propnum))] = key
                h["propValue{0}".format(str(propnum))] = value
                propnum = propnum + 1
            #end for
        #end if
        h["alertEnable"] = alertenable
        return h
    #end _buildhosthash
    
    def _verifyproperty(self, propname):
        """Check with LogicMonitor server to verify property is unchanged"""
        if self.info:
            if propname not in self.properties:
                return False
            else:
                resp = json.loads(self.rpc('verifyProperties', {"hostId": self.info["id"], "propName0": propname, "propValue0": self.properties[propname]}))
                if resp["status"] == 200:
                    return resp["data"]["match"]
                else:
                   self.module.fail_json(msg="Error: unable to get verification from server.\n%s" % resp["errmsg"])
            #end if
        else:
           self.module.fail_json(msg="Error: Can not verify properties of a host which doesn't exist")
    #end _verifyproperty
    
    
#end class lm_host

#========================================

def selector(module):
    """Figure out which object and which actions to take given the right parameters"""
    if module.params['target'] == 'collector':
        target = Collector(module)
    elif module.params['target'] == 'host':
        target = Host(module)
    elif module.params['target'] == 'hostgroup':
        #target = Hostgroup(module)
        pass
    else: #handles the EOTW case
        module.fail_json(msg="Error: Something very strange happened. An unexpected target was specified.")
    #end
    
    if module.params['action'] == 'add':
        action = target.create
    elif module.params['action'] == 'remove':
        action = target.remove
    elif module.params['action'] == 'sdt':
        action = target.sdt
    else:
        module.fail_json(msg="Error: Something very strange happened. An unexpected action was specified.")
    #end if
    
    exit_code = action()
    module.exit_json(changed=target.change)
    
#end selector
    

def main():
    """docstring for main"""
    TARGETS=[
        'collector',
        'host',
        'hostgroup',
    ]
    
    ACTIONS=[
        'add',
        'remove',
        'sdt',
    ]
    
    module = AnsibleModule(
        argument_spec = dict(
            target=dict(required=True, default=None, choices=TARGETS),
            action=dict(required=True, default=None, choices=ACTIONS),
            company=dict(required=True, default=None),
            user=dict(required=True, default=None),
            password=dict(required=True, default=None),
            collector=dict(required=False, default=None),
            hostname=dict(required=False, default=None),
            displayname=dict(required=False, default=None),
            description=dict(required=False, default=""),
            properties=dict(required=False, default={}),
            groups=dict(required=False, default=[]),
            fullpath=dict(required=False, default=None),
            alertenable=dict(required=False, default=True),
            starttime=dict(required=False, default=None),
            duration=dict(required=False, default=30),
        ),
        supports_check_mode=True
    )
    selector(module)
    
#end main

# include magic from lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>
main()